1. BIO
	1. 同步并阻塞
	2. 一个连接一个线程 ，客户端请求服务器的时候就会启动一个线程进行连接，如果连接了什么事都不做就会造成不必要的线程开销，而且如果客户端很多那么服务端就要提供相应的线程
	3. **适用于连接数较小且固定的架构**，这种方式对服务器资源的要求比较高，并局限于应用中，jdk1.4以前的唯一选择，程序简单并且易理解
	4. client启动socket连接到server后，只会建立一个阻塞的链接，如果此时有别的client消息请求就会创建一个新的线程启动一个新的链接
	5. 每个socket接收到都会创建一个线程，线程的竞争比如争内存片，切换上下文影响性能
	6. 每个线程都会占用栈内存和CPU内存
	7. 并不是每个线程都会进行io操作，无意义的线程浪费内存
	8. 客户端并发访问量增加的时候，服务端将会1:1的线程开销，访问量过大会产生线程堆栈溢出
2. NIO
	1. 同步非阻塞
	2. 一个线程可以处理多个请求（连接），客户端发送的请求都会到一个多路复用器上，多路复用器轮询到有i/o连接就处理如果没有就不处理
	3. **适用于连接数较多且固定的架构（轻操作）**，比如聊天服务器，弹幕系统，服务器之间的通讯，编程比较复杂，jdk1.5开始支持
	4. **面向缓冲区，基于通道操作**
	5. NIO三大核心，channel，buffer，selector
		1. channel： 通道，nio的通道与流类似，可以从通道中读数据也可以写数据而流是单向的，通道支持非阻塞读取和写入通道
		2. buffer： 缓冲区，本质上是一块可以读取的内存，被封装成了NIO的buffer对象，并提供了一组方法
			1. 容量（capacity），
			2. 限制（limit），表示缓冲区可以操作数据的大小，limit后的数据不能读写，写入模式限制等于buffer容量，读取模式下limit等于写入的数据量
			3. 位置（position），下一个要读取或者写入的数据的索引，位置不能为负并且不能大于限制
			4. 标记（mark）与重置（reset），标记是一个索引，通过buffer的mark（）方法指定buffer中的一个特定的位置然后使用reset（）方法恢复到这个位置
		3. selector，选择器（多路复用器），是一个NIO的组件，可以检查一个或者多个NIO通道，并确定哪些通道已经准备好进行读取或者写入，这样一个线程就可以管理多个channel，从而管理多个连接
	6. 程序切换到哪个channel是由事件决定的
	7. NIO是以块的方式处理数据，BIO是以流的方式处理数据
3. AIO
	1. NIO2.0
	2. 异步非阻塞
	3. 一个有效线程一个连接，客户端的i/o请求都是由OS先完成了再通知服务器去启动线程进行处理，一般适用于连接数较多且连接时间较长的应用
	4. **适用于连接数较多且比较长的架构（重操作）**，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，jdk7开始支持