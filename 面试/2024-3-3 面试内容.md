1. crm系统介绍
		[[crm]]
2. 兜底系统
	1. 定时检查订单表和出库记录，以及积分的消费记录，看看是不是对等的
3. mysql的事务隔离机制
	1. 读未提交，允许脏读，就是在该隔离级别下，可能读到其他会话未提交事务修改的数据，存在脏读、不可重读读、幻读的问题。
	2. 读已提交，只能查询到已提交的数据。这是 Oracle 数据库默认的事务隔离级别。存在不可重读读、幻读的问题。
	3. 可重复读，在一个事务里相同条件下，无论何时查到的数据都和第一次查到的数据一致。这是 MySQL 数据库 InnoDB 引擎默认的事务隔离级别。在范围查询时存在幻读的问题。
	4. 串行化，严格服从 ACID 特性的隔离级别。所有的事务依次逐个执行，事务之间互不干扰，该级别可以防止脏读、不可重复读以及幻读。但每个事务读数据时都需要获取表级的共享锁，导致读和写都会阻塞，性能极低。
5. 什么是脏读，幻读和不可重复读
	1. **脏读**指的**是**一个事务**读**到了其他事务未提交的数据
	2. **不可重复读**指的**是**一个事务中多次**读**到同一条数据发生了变化，重点在于表中已经存在的数据被其他事务修改了
	3. **幻读**指的**是**一个事务被其他事务插入或者删除的数据有影响，重点在于事务开始后，其他事务插入或删除了数据。
6. 事务的传播机制
7. mysql的存储引擎，有什么区别
	1. **InnoDB**是MySQL默认的事务性存储引擎，支持事务、ACID属性（原子性、一致性、隔离性、持久性），提供行级锁定和外键约束。适用于需要事务支持和高并发读写操作的应用。
	2. **MyISAM**是MySQL的另一种常见存储引擎，它不支持事务和行级锁定，但具有较高的读取性能，适用于读密集型应用，如数据仓库。
	3. MEMORY（或 HEAP）存储引擎将表数据存储在内存中，提供快速的读写性能。然而，它对于大型数据集不太适用，因为所有数据都存储在内存中。
	4. ARCHIVE存储引擎被设计用于大量插入和少量查询的场景，对于归档和日志数据非常有效。它采用压缩算法来减小磁盘空间占用。
	5. CSV存储引擎将表数据存储在CSV格式的文件中，适用于数据交换和导入导出。但它通常不适合大规模的查询和写入操作。
	6. TokuDB是一个高性能的事务性存储引擎，专注于提供优秀的写入性能，支持大容量的数据和高度压缩。适用于大数据存储和处理。
8. mysql有哪几种索引
	1. 普通索引：允许重复的值
	2. 唯一索引：不允许有重复的值
	3. 主键索引(哈希索引)：数据库自动为我们的主键创建索引，如果我们没有指定主键，它会根据没有 null 的唯一索引创建主键索引，否则会默认根据一个隐藏的 rowId 作为主键索引
	4. 全文索引，用来对文本域进行索引，比如 text，varchar，只针对 MyISAM 有效
9. mysql有哪几种约束
	1. 非空约束(not null) 用not null约束的字段不能为null值，必须给定具体的数据
	2. 唯一性约束(unique) [unique](https://so.csdn.net/so/search?q=unique&spm=1001.2101.3001.7020)约束的字段，具有唯一性，不可重复，但可以为null
	3. 主键约束(primary key) PK
	4. 外键约束(foreign key) FK，若有两个表A、B，id是A的主键，而B中也有id字段，则id就是表B的外键，外键约束主要用来维护两个表之间数据的一致性。A为基本表，B为信息表
10. rabbitmq的组件
	1. **broker** RabbitMQ服务器
	2. **vHost** 虚拟主机
	3. **Exchange 交换机** 交换机的作用就是根据路由规则，将消息转发到对应的队列上。
	4. **Connection**
	5. **ConnectionFactory** Connection工厂，负责创建和管理Connection的。
	6. **Channel** 
	7. **Routing key** Routing key是消息头的属性，生产者将消息发送到交换机时，会在消息头上携带一个key，这个key就是routing key，来指定这个消息的路由规则。
	8. **Binding**
11. mysql优化
	1. 检查慢sql进行优化
	2. 常用的查询进行缓存，因为mysql8不支持缓存了，所以一般是缓存到redis里
	3. 为经常查询的字段创建索引
	4. 如果是大表的话进行分表
	5. 左右内连接的列最好是有索引
	6. 减少使用（通配符）%like
	7. 不要在索引字段上使用not，<>，!=， key<>0 改为 key>0 or key<0
12. mysql行锁和表锁
	1. **行锁**：MySQL中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。**行级锁分为共享锁和排他锁**。特点：行锁开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
	2. 表锁：MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MyISAM与InnoDB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。特点：表锁开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发最低。
	3. 
13. redis的RDB和AOF
	1. **RDB** 产生一个数据快照文件，因为不是完全和实例一致的，所以一般用于主从全量同步数据，数据库备份，对于丢失数据不敏感的业务场景，实例宕机后快速恢复数据
	2. **AOF**  追加日志文件，将redis的每条操作记录来将完整的命令记录到日志里，故障的时候来进行恢复，数据刷盘
14. 怎么避免死锁的发生，以及如果发生死锁，该怎么恢复
	1. 如果事务涉及多个表，操作比较复杂，那么可以尽量一次锁定所有的资源，而不是逐步来获取，这样可以减少死锁发生的概率；
	2. 如果事务需要更新数据表中的大部分数据，数据表又比较大，这时可以采用锁升级的方式，比如将行级锁升级为表级锁，从而减少死锁产生的概率；
	3. 不同事务并发读写多张数据表，可以约定访问表的顺序，采用相同的顺序降低死锁发生的概率
15. spring cloud的组件
	1. **服务注册和服务发现**
		1. eureka
		2. nacos
	2. **分布式配置管理**
		1. config
	3. **批量任务框架**
	4. **服务调用**
		1. open Feign
		2. okhttp
	5. **负载均衡**
		1. Ribbon
	6. **网关**
		1. Zuul
		2. gateway
	7. **链路追逐**
	8. **熔断器**
		1. Hystrix
		2. Sentinel

